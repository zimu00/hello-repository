DWORD buf[BUFLEN];
while(buf[i]!='\r')
----->not ok,cz buf is integer value,(in exam don't waste time in this,just read from a file)

//scanf always expect \n,so enter after every number
_tscanf(_T("%d"),&buf[i]);//don't forget &!!!!!!
before record,for every scanf also enters enter

they can't have same semaphore for four threads,cz one thread can repeat several times

THe error like expected a declaration or statement usually is due to the } or {

don't forget every global varaible needs to be protected
and signal wait pair pair
Closing a thread handle does not terminate the associated thread or remove the thread object. Closing a process handle does not terminate the associated process or remove the process object. To remove a thread object, you must terminate the thread, then close all handles to the thread. For more information, see Terminating a Thread. To remove a process object, you must terminate the process, then close all handles to the process. For more information, see Terminating a Process.

Needs to add another limitation like counter and needs to be protected,otw only 4th thread reset,but others who has executed before can still
have that signal before resetting,then go on executing.....


case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
			*ECatgry = 1;
			return EXCEPTION_EXECUTE_HANDLER;still needs 4 different semaphores cz here is different with event,we only have  4 semaphores,if two is taken by same thread, there must be one
thread can't go on

static functions are functions that are only visible to other functi
ons in the same file

Error Code 36: Too many files opened for sharing. [ERROR_SHARING_BUFFER_EXCEEDED (0x24)]
then i used FILE_SHARE_READ

DWORD is unsigned,INT is signed,so if need to have negative value and compare with 0,better use INT

buf = (DWORD *)calloc(temp,sizeof(DWORD));

first declare in check2 function:INT *buf,and initialized in try block,in finally want to free it,but can't cz unitialized error,
so can just declare in this way:INT *buf=NULL


when i put finally in inner part,the program really executes finally 1st,then except

The __try block terminates normally only if execution leaves the block sequentially after executing the last statement in the block. Statements (such as return, goto, continue, or break) that cause execution to leave the __try block result in abnormal termination of the block. This is the case even if such a statement is the last statement in the __try block.
Abnormal termination of a __try block causes the system to search backward through all stack frames to determine whether any termination handlers must be called. This can result in the execution of hundreds of instructions, so it is important to avoid abnormal termination of a __try block due to a return, goto, continue, or break statement. Note that these statements do not generate an exception, even though the termination is abnormal.
To avoid abnormal termination, execution should continue to the end of the block. You can also execute the __leave statement. The __leave statement allows for immediate termination of the __try block without causing abnormal termination and its performance penalty. Check your compiler documentation to determine if the __leave statement is supported.


writefile(&n),n=0,check error code:access is denied,then found in parameters of createfile: should be GENERIC_WRITE instead of GENERIC_READ

locking a file for writing must set dwFlags,otw the request is for a shared(read only) lock


for exclusive lock,it can't grant a new lock on the same field.Before the program stopped in second lock,cz i need to write the whole part
relating to filepos,not only filepos.quadpart.

fgets and scanf both want \n,so after every input,must have an \n

CreateProcess failed 998:
forget to zero si,pi
(You declare this as your buffer for ReadFile:
LPVOID* ntns;
But this isn't a buffer, it's just a pointer to some random chunk of memory that you don't own.

Then you attempt to read 1000000 bytes into this buffer without having actually allocated any memory:
int x=ReadFile(hfile, ntns, 1000000, NULL, NULL);

MSDN states:

lpBuffer [out]
A pointer to the buffer that receives the data read from a file or device.
This buffer must remain valid for the duration of the read operation. The caller must not use this buffer until the read operation is completed.)

should add this:
ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

Createprocess failed with 193:
The most likely explanations for that error are:

The file you are attempting to load is not an executable file. CreateProcess requires you to provide an executable file. If you wish to be able to open any file with its associated application then you need ShellExecute rather than CreateProcess.
There is a problem loading one of the dependencies of the executable, i.e. the DLLs that are linked to the executable. The most common reason for that is a mismatch between a 32 bit executable and a 64 bit DLL, or vice versa. To investigate, use Dependency Walker's profile mode to check exactly what is going wrong.
