DWORD buf[BUFLEN];
while(buf[i]!='\r')
----->not ok,cz buf is integer value,(in exam don't waste time in this,just read from a file)

//scanf always expect \n,so enter after every number
_tscanf(_T("%d"),&buf[i]);//don't forget &!!!!!!
before record,for every scanf also enters enter

they can't have same semaphore for four threads,cz one thread can repeat several times

THe error like expected a declaration or statement usually is due to the } or {

don't forget every global varaible needs to be protected
and signal wait pair pair
Closing a thread handle does not terminate the associated thread or remove the thread object. Closing a process handle does not terminate the associated process or remove the process object. To remove a thread object, you must terminate the thread, then close all handles to the thread. For more information, see Terminating a Thread. To remove a process object, you must terminate the process, then close all handles to the process. For more information, see Terminating a Process.

Needs to add another limitation like counter and needs to be protected,otw only 4th thread reset,but others who has executed before can still
have that signal before resetting,then go on executing.....


case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
			*ECatgry = 1;
			return EXCEPTION_EXECUTE_HANDLER;still needs 4 different semaphores cz here is different with event,we only have  4 semaphores,if two is taken by same thread, there must be one
thread can't go on

static functions are functions that are only visible to other functi
ons in the same file

Error Code 36: Too many files opened for sharing. [ERROR_SHARING_BUFFER_EXCEEDED (0x24)]
then i used FILE_SHARE_READ

DWORD is unsigned,INT is signed,so if need to have negative value and compare with 0,better use INT

buf = (DWORD *)calloc(temp,sizeof(DWORD));
