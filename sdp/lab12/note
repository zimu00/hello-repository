DWORD buf[BUFLEN];
while(buf[i]!='\r')
----->not ok,cz buf is integer value,(in exam don't waste time in this,just read from a file)

//scanf always expect \n,so enter after every number
_tscanf(_T("%d"),&buf[i]);//don't forget &!!!!!!
before record,for every scanf also enters enter

they can't have same semaphore for four threads,cz one thread can repeat several times

THe error like expected a declaration or statement usually is due to the } or {

don't forget every global varaible needs to be protected
and signal wait pair pair
Closing a thread handle does not terminate the associated thread or remove the thread object. Closing a process handle does not terminate the associated process or remove the process object. To remove a thread object, you must terminate the thread, then close all handles to the thread. For more information, see Terminating a Thread. To remove a process object, you must terminate the process, then close all handles to the process. For more information, see Terminating a Process.

Needs to add another limitation like counter and needs to be protected,otw only 4th thread reset,but others who has executed before can still
have that signal before resetting,then go on executing.....


case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
			*ECatgry = 1;
			return EXCEPTION_EXECUTE_HANDLER;still needs 4 different semaphores cz here is different with event,we only have  4 semaphores,if two is taken by same thread, there must be one
thread can't go on

static functions are functions that are only visible to other functi
ons in the same file

Error Code 36: Too many files opened for sharing. [ERROR_SHARING_BUFFER_EXCEEDED (0x24)]
then i used FILE_SHARE_READ

DWORD is unsigned,INT is signed,so if need to have negative value and compare with 0,better use INT

buf = (DWORD *)calloc(temp,sizeof(DWORD));

first declare in check2 function:INT *buf,and initialized in try block,in finally want to free it,but can't cz unitialized error,
so can just declare in this way:INT *buf=NULL


when i put finally in inner part,the program really executes finally 1st,then except

The __try block terminates normally only if execution leaves the block sequentially after executing the last statement in the block. Statements (such as return, goto, continue, or break) that cause execution to leave the __try block result in abnormal termination of the block. This is the case even if such a statement is the last statement in the __try block.
Abnormal termination of a __try block causes the system to search backward through all stack frames to determine whether any termination handlers must be called. This can result in the execution of hundreds of instructions, so it is important to avoid abnormal termination of a __try block due to a return, goto, continue, or break statement. Note that these statements do not generate an exception, even though the termination is abnormal.
To avoid abnormal termination, execution should continue to the end of the block. You can also execute the __leave statement. The __leave statement allows for immediate termination of the __try block without causing abnormal termination and its performance penalty. Check your compiler documentation to determine if the __leave statement is supported.
